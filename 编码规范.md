# 编码规范

## 1.变量初始化必须赋值

> 下述代码不能保证`\0`结尾

```
WCHAR StrNameBuf[260];
memcpy(StarNameBuf, sourceNameBuf, sourceNameBufLength);
```



## 2.有效资源的变量值为非空，否则为NULL

> 资源做释放后一定要置空

```
ExFreePoolTag(pData, 0);
pData = 0;
```



## 3.申请资源要做有效性判断

> 在内核编程过程中，肯定需要向系统申请某些资源，常见的资源有内存、文件、事件对象、线程对象等。在理想的情况下，这些资源申请均可成功，但是在系统资源不足的情况下，资源申请可能会失败。
>
> 最常见的例子是内存申请失败。



## 4.某些场景下，资源需要一次性申请

> 在低资源环境下，内核中申请的资源很有可能失败，对于一些逻辑来说，一旦资源申请失败将无法继续往下执行，或者往下执行一定会蓝屏。
>
> 例如在windows的驱动中，等待线程停止的函数 `KeWaitForMultipleObjects ` 也需要非分页内存，如果此时非分页内存紧张，就会导致无法停止线程，最严重的结果就是蓝屏。
>
> 较好的解决方法是在`DriverEntry`中把`KeWaitForMultipleObjects`所需要的资源申请好，即“一次性申请”到位。通俗来讲，就是需要把这类情况全部梳理出来，这些内存或资源对于自身驱动来说是“性命攸关”的资源，应该放在`DriverEntry`中申请，一旦申请失败，驱动`DriverEntry`也应返回失败。



## 5.独立性与最小化原则

> 独立性:
>
> 在方案选型时，如果选择了系统提供的机制，不妨从可靠性、稳定性、可替代性等几个方面来对方案进行评估。对于`WorkItem`(内核驱动程序需要延时处理一些逻辑，这些逻辑可以放到`WorkItem`中处理)，在可靠性方面来看，`WorkItem`并非一个100%可靠的方案，开发者其实可以通过自己创建系统线程来执行需要延迟处理的逻辑。
>
> 最小化原则:
>
> 所谓最小化原则，具体是指内核驱动使用最少的资源来完成自身逻辑。
>
> “最小化原则”资源占用最小化。提出的原因在于内核中的一些资源相当珍贵，如非分页内存 。在 IRQL 处 于DISPATCH_LEVEL或更高级别的时候，只能访问非分页内存，很多开发者为了简单起见，在所有需要申请内存的地方都使用了非分页内存，这样做的好处是开发者可以不用担心IRQL的问题，坏处是造成了非分页内存浪费，在一些可以使用分页内存的地方使用了非分页内存，一旦内存紧张，很有可能导致非分页内存申请失败，最终导致逻辑处理失败。所以这个做法加大了逻辑处理的失败率。
>
> 线程同步在内核开发中也非常常见，常用的同步方式有：自旋锁、事件对象、资源锁等。不同的同步机制所适合的场景、对应的IRQL不同，但自旋锁适用于任何一种场景。由于自旋锁使用简单，很多初学者不管在什么场景，一律使用自旋锁，这虽然是一个可行的方案，但是对于自旋锁来说，加锁后，IRQL会提升DISPATCH_LEVEL，在这个IRQL，当前CPU被独占，不能调度其他线程，从这个角度来看，对系统性能的影响是巨大的，也违背了“最小化原则”。
>
> 自身逻辑“最小化”。系统处于低资源或者中毒状态，自身驱动模块加载时，会遇到一些操作失败的情况，如创建线程失败、写入文件失败等。如果驱动模块遇到一个“小错误”就认为全部执行失败，明显是不合理的。开发者应该对驱动的逻辑进行分类，标识出哪些逻辑是“关键逻辑”，哪些逻辑是“非关键逻辑”，“非关键逻辑”的失败不影响整体驱动执行流程，只有当“关键逻辑”失败时，整体驱动才宣告失败。



## 6.嵌套陷阱

> Windows内核为开发者提供了一系列回调机制，这些机制可以被用于监控、拦截某些系统行为。如“对象回调”可以监控进程和线程句柄的打开、关闭以及复制操作；“注册表回调”可以监控系统的所有注册表行为。
>
> （1）开发者必须清楚了解代码中所调用的系统API是否会发生嵌套。
>
> （2）对于存在嵌套的系统API，务必保证在调用线程中，尽可能少使用栈空间，如需要使用大量内存，可以通过在POOL上申请后使用。
>
> （3）同理，对于自身执行在过滤驱动或回调函数中的代码，也尽可能少使用栈空间。
>
> （4）对于自身执行在过滤驱动或回调函数中的代码，如果需要调用存在嵌套的系统API，可以考虑把API的调用位置放置在另外一个工作线程中，然后通过线程间通信把系统API调用结果返回给最初线程。
>
> （5）避免在代码中使用递归，如果非要使用递归，请控制好递归的深度。





## 7.稳定性处理

### 事前处理 

> 常见的驱动测试分为逻辑测试、异常情况测试、压力测试以及兼容性测试。
>
> 逻辑测试主要是测试驱动的业务逻辑。
>
> 异常情况测试主要是验证驱动在极端环境下或遇到异常数据输入时的表现。所谓极端环境，是指系统资源不足、IO异常繁忙、CPU无法调度、API无故返回错误等一系列情况。异常数据输入是指：驱动与应用层进程进行数据交互时，应用层传递一个错误或畸形的数据，如大小非法、格式不符合预期等。（Verifier驱动校验）。

### 事中处理 

> 稳定性的事中处理是指蓝屏或者兼容性问题发生时，为了保全大局，临时关闭驱动以恢复系统正常工作以及提取必要的故障信息的过程。
>
> 以常见杀毒软件的主动防御模块为例，在逻辑层面，主动防御模块一般会分为文件监控、注册表监控、进程监控、线程监控、注入检测等等。每一个模块都需要设置一个“开关”，所谓的“开关”，其实是后台服务器的一组标志，这些标志表示客户端驱动的某一个功能或模块的开启情况。
>
> 驱动开发者可以注册一套“系统关机回调”，`IoRegisterShutdownNotification`成功注册后，当系统进入关机或者重启逻辑时，系统会向`DeviceObject`设备对象发送`IRP_MJ_SHUTDOWN`请求，开发者可以在这个请求中进行一些关机或重启前的逻辑处理。为何通过关机消息，可以在一定程度实现驱动“止损”？原因是：当驱动发生蓝屏时，系统并不会触发`IRP_MJ_SHUTDOWN`，一旦系统触发了`IRP_MJ_SHUTDOWN`，开发者可以认为系统本次是正常关机或重启。开发者可以在本次接收到`IRP_MJ_SHUTDOWN`时，往注册表或文件中写入一个用于表明当前成功关机或重启的信息，在下次系统启动时，`Safe.sys`驱动加载后，检查相应的注册表或文件是否被记录了“成功关机或重启”信息，如果是，则表明上次系统没有蓝屏，本次驱动可以继续正常加载逻辑，否则表明上次系统异常关机或重启，可能是发生了蓝屏，也可能是系统异常断电，在这种情况下，`Safe.sys`驱动程序可以暂时不工作，应用程序可以检查系统目录是否有DUMP文件生成来进一步确认系统是否蓝屏。
>
> 如果一个驱动已经注册了 “ 系 统 关 机 回 调 ” 当这个驱动需要卸载时 ，必须调`IoUnregisterShutdownNotification` 函数来移除 “ 系 统 关 机 回 调 ”。

### 事后处理

> 最后为读者介绍稳定性的事后处理，事后处理更多是分析驱动的具体缺陷原因，修改或规避掉相应的问题，重新发布新的驱动。



